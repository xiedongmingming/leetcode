Integer to Roman

Given an integer, convert it to a roman numeral. 
Input is guaranteed to be within the range from 1 to 3999.

罗马数字是由字符I,V,X,L,C,D,M等等表示的，其中
I = 1;
V = 5;
X = 10;
L = 50;
C = 100;
D = 500;
M = 1000;
接下来应该是V开始的重复，但是上面要加一个横线，表示对应数字的1000倍。
个位应该是：I,II,III,IV,V,VI,VII,VIII,IX
十位应该是：X,XX,XXX,XL,L,LX,LXX,LXXX,XC
百位应该是：C,CC,CCC,CD,D,DC,DCC,DCCC,CM


题解：


这道题。。还有哪个roman to integer。。第一件事 就是先把roman认全吧。。

 

 罗马数字拼写规则（转自Wikipedia：http://zh.wikipedia.org/wiki/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97）：

_R底止灿7，即I（1）、V（5）、X（10）、L（50）、C（100）、D（500）和M（1000）。按照下述的t可以表示任意正整怠Ｐ枰注意的是罗马数字中没有“0”，cM位制oP。一般J榱_R底种挥碛担而不作演算。

?重}荡危阂_R底种匮}状危就表示@档妆丁
?右加左p： 
?在^大的_R底值挠疫上^小的_R底郑表示大底旨有底帧
?在^大的_R底值淖筮上^小的_R底郑表示大底旨跣底帧
?左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV
?但是，左pr不可跨越一位怠１热纾99不可以用IC（）表示，而是用XCIX（）表示。（等同於阿拉伯底置课底址e表示。）
?左p底直仨橐晃唬比如8成VIII，而非IIX。
?右加底植豢蛇Bm超^三位，比如14成XIV，而非XIIII。（下方“荡a限制”一。）
?加乘千： 
?在_R底值纳戏郊由弦lM或者加上下说?，表示⑦@党艘1000，即是原档1000倍。
?同理，如果上方有lM，即是原档1000000（）倍。
?荡a限制： 
?同一荡a最多只能出F三次，如40不可表示XXXX，而要表示XL。
?例外：由於IV是古_R神主神朱庇特（即IVPITER，古_R字母e]有J和U）的首字，因此有r用IIII代替IV。
 

 

根据上述规则，我们可以发现两条对解这道题有帮助的内容：

?左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV
?但是，左pr不可跨越一位怠１热纾99不可以用IC（）表示，而是用XCIX（）表示。（等同於阿拉伯底置课底址e表示。）
?左p底直仨橐晃唬比如8成VIII，而非IIX。
有以上三个内容我们可以发现在减数的时候有特定的规律，就是只能减1位且不能跨越一个位数，同时只限于I X C。


像上面那个例子，99 不能用IC(100-1)表示，是因为如果一个数字超过90（或等于90），其罗马数字的表示就必须包含一个XC（100-10）。

同理，对I X C都适用这个原则。


这个判断，要从最大往下找，如果一个数字是5，那么他就是属于大于等于5，罗马数字包含V，而无需写成IIIII。

所以，递归的，代码可以写成如下（代码源自leetcode discussion）：
public String intToRoman(int num) {
        if(num>=1000) return "M"+intToRoman(num-1000);
        if(num>=900) return "CM"+intToRoman(num-900);
        if(num>=500) return "D"+intToRoman(num-500);
        if(num>=400) return "CD"+intToRoman(num-400);
        if(num>=100) return "C"+intToRoman(num-100);
        if(num>=90) return "XC"+intToRoman(num-90);
        if(num>=50) return "L"+intToRoman(num-50);
        if(num>=40) return "XL"+intToRoman(num-40);
        if(num>=10) return "X"+intToRoman(num-10);
        if(num>=9) return "IX"+intToRoman(num-9);
        if(num>=5) return "V"+intToRoman(num-5);
        if(num>=4) return "IV"+intToRoman(num-4);
        if(num>=1) return "I"+intToRoman(num-1);
        return "";
    }
 
public String intToRoman(int num) {
        String str = "";    
        String [] symbol = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};    
        int [] value = {1000,900,500,400, 100, 90,  50, 40,  10, 9,   5,  4,   1};   
        for(int i=0;num!=0;i++){  
            while(num >= value[i]){  
                num -= value[i];  
                str += symbol[i];  
            }  
        }  
        return str;  
    }



public class Solution{
    String[][] roman = {
		{"", "I","II","III","IV","V","VI","VII","VIII","IX"},
		{"", "X","XX","XXX","XL","L","LX","LXX","LXXX","XC"},
		{"", "C","CC","CCC","CD","D","DC","DCC","DCCC","CM"},
		{"", "M","MM","MMM","  "," ","  ","   ","    ","  "},
		{"", "", "","","","","","","",""}
	};
	public String intToRoman(int num){
		if(num > 3999 || num < 1){
			return "";
		}
		int m = 1, d = 1;
		while(m <= num){
			m *= 10;
			d++;
		}
		String rs = new String();
		while(m > 0){
			rs += (roman[--d][num / m]);
			num = num % m;
			m = m / 10;
		}
		return rs;
	}
}





public void romanstr(String roman, int num, char[] symbol){
	if(num == 0)return;
	else if(num <= 3) roman.append(num, *symbol);
	else if(num == 4){
		roman.append(1,*symbol);
		roman.append(1,*(symbol+1));
	}else if(num <= 8){
		roman.append(1,*(symbol+1));
		roman.append(num-5,*symbol);
	}else if(num == 9){
		roman.append(1,*symbol);
		roman.append(1,*(symbol+2));
	}
}
String intToRoman(int num){ 
	char[] symbol = {'I', 'V', 'X', 'L', 'C', 'D', 'M'};
	String roman = "";
	int scale = 1000;
	int p = 6;
	while(num){
		int bit = num / scale;
		romanstr(roman, bit, symbol + p);
		num = num % scale;
		scale /= 10;
		p -= 2;
	}
	return roman;
}
